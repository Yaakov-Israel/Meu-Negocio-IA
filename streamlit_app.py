import streamlit as st
import os 
import json 
import pyrebase 
from langchain_google_genai import ChatGoogleGenerativeAI
from langchain.prompts import ChatPromptTemplate, SystemMessagePromptTemplate, HumanMessagePromptTemplate, MessagesPlaceholder
from langchain.chains import LLMChain
from langchain.memory import ConversationBufferMemory
from langchain.schema import HumanMessage, AIMessage
import google.generativeai as genai
from PIL import Image # Para o logo na sidebar

# --- Configura√ß√£o da P√°gina Streamlit ---
st.set_page_config(
    page_title="Assistente PME Pro",
    layout="wide",
    initial_sidebar_state="expanded",
    page_icon="üöÄ" 
)
# O st.title() ser√° definido dentro das se√ß√µes para ser din√¢mico.
# --- Inicializa√ß√£o do Firebase ---
firebase_app = None
pb_auth_client = None
error_message_firebase_init = None
firebase_initialized_successfully = False
auth_exception_object = None # Para armazenar o objeto de exce√ß√£o para st.exception

try:
    firebase_config_from_secrets = st.secrets.get("firebase_config")
    if not firebase_config_from_secrets:
        error_message_firebase_init = "ERRO CR√çTICO: A se√ß√£o '[firebase_config]' n√£o foi encontrada ou est√° vazia nos Segredos."
    else:
        plain_firebase_config_dict = {k: v for k, v in firebase_config_from_secrets.items()}
        required_keys = ["apiKey", "authDomain", "projectId", "storageBucket", "messagingSenderId", "appId"]
        missing_keys = [key for key in required_keys if key not in plain_firebase_config_dict]

        if missing_keys:
            error_message_firebase_init = f"ERRO CR√çTICO: Chaves faltando em [firebase_config] nos segredos: {', '.join(missing_keys)}"
        else:
            if 'firebase_app_instance' not in st.session_state: 
                st.session_state.firebase_app_instance = pyrebase.initialize_app(plain_firebase_config_dict)
            
            firebase_app = st.session_state.firebase_app_instance
            pb_auth_client = firebase_app.auth()
            firebase_initialized_successfully = True
            if 'firebase_init_success_message_shown' not in st.session_state and not st.session_state.get('user_session_pyrebase'):
                 st.sidebar.success("‚úÖ Firebase SDK (Pyrebase4) inicializado!")
                 st.session_state.firebase_init_success_message_shown = True

except KeyError:
    error_message_firebase_init = "ERRO CR√çTICO: A se√ß√£o '[firebase_config]' n√£o foi encontrada nos Segredos do Streamlit."
    auth_exception_object = Exception(error_message_firebase_init)
except AttributeError as e_attr_fb: 
    error_message_firebase_init = f"ERRO CR√çTICO ao acessar st.secrets['firebase_config']: {e_attr_fb}"
    auth_exception_object = e_attr_fb
except Exception as e_general_fb: 
    error_message_firebase_init = f"ERRO GERAL ao inicializar Pyrebase4: {e_general_fb}"
    auth_exception_object = e_general_fb

if error_message_firebase_init:
    st.error(error_message_firebase_init)
    if auth_exception_object and ('st' in locals() or 'st' in globals()):
        st.exception(auth_exception_object)
    st.stop()

if not firebase_initialized_successfully or not pb_auth_client:
    st.error("Falha cr√≠tica na inicializa√ß√£o do Firebase. O app n√£o pode continuar.")
    st.stop()

# --- L√≥gica de Autentica√ß√£o e Estado da Sess√£o ---
if 'user_session_pyrebase' not in st.session_state:
    st.session_state.user_session_pyrebase = None

user_is_authenticated = False
if st.session_state.user_session_pyrebase and 'idToken' in st.session_state.user_session_pyrebase:
    try:
        refreshed_user_info = pb_auth_client.get_account_info(st.session_state.user_session_pyrebase['idToken'])
        st.session_state.user_session_pyrebase['email'] = refreshed_user_info['users'][0].get('email', "Email n√£o dispon√≠vel")
        user_is_authenticated = True
        st.session_state.pop('auth_error_shown', None) 
    except Exception as e_session: 
        error_message_session_check = "Sess√£o inv√°lida ou expirada."
        try:
            error_details_str = e_session.args[0] if len(e_session.args) > 0 else "{}"
            error_data = json.loads(error_details_str.replace("'", "\"")) 
            api_error_message = error_data.get('error', {}).get('message', "ERRO_DESCONHECIDO_SESSAO")
            if "TOKEN_EXPIRED" in api_error_message or "INVALID_ID_TOKEN" in api_error_message:
                error_message_session_check = "Sua sess√£o expirou. Por favor, fa√ßa login novamente."
            else: 
                error_message_session_check = f"Erro ao verificar sess√£o ({api_error_message}). Fa√ßa login."
        except (json.JSONDecodeError, IndexError, TypeError, AttributeError): 
            error_message_session_check = f"Erro ao verificar sess√£o (parsing). Fa√ßa login. Detalhe: {str(e_session)}"
        
        st.session_state.user_session_pyrebase = None 
        user_is_authenticated = False
        if 'auth_error_shown' not in st.session_state: 
            st.sidebar.warning(error_message_session_check)
            st.session_state.auth_error_shown = True
        
        # Controle de rerun para evitar loops infinitos
        session_rerun_key = 'running_rerun_after_auth_fail_v3' # Nova chave para esta vers√£o
        if not st.session_state.get(session_rerun_key, False):
            st.session_state[session_rerun_key] = True
            st.rerun()
        else:
            st.session_state.pop(session_rerun_key, None)

# Limpeza da flag de rerun se ela existir e o c√≥digo continuar
session_rerun_key_check = 'running_rerun_after_auth_fail_v3'
if session_rerun_key_check in st.session_state and st.session_state[session_rerun_key_check]:
    st.session_state.pop(session_rerun_key_check, None)
    # Se um rerun foi for√ßado, pode ser necess√°rio parar a execu√ß√£o aqui
    # para evitar que o resto da UI seja renderizado incorretamente antes do rerun.
    # No entanto, o rerun deve acontecer antes de chegar aqui na pr√≥xima execu√ß√£o.
    # Se a flag ainda estiver aqui, √© uma situa√ß√£o estranha, mas vamos limp√°-la.
# --- Interface do Usu√°rio Condicional e L√≥gica Principal do App ---
# Usaremos o sufixo de chave do seu c√≥digo original (_v20_final) onde apropriado
# para a l√≥gica do aplicativo, e chaves distintas para a autentica√ß√£o.
APP_KEY_SUFFIX = "_v20_final" # Suffix do seu c√≥digo original para as funcionalidades

if user_is_authenticated:
    st.session_state.pop('auth_error_shown', None) 
    display_email = st.session_state.user_session_pyrebase.get('email', "Usu√°rio Logado")
    
    # Inicializa√ß√£o do LLM (S√ì SE AUTENTICADO)
    GOOGLE_API_KEY = st.secrets.get("GOOGLE_API_KEY")
    llm_model_instance = None
    llm_init_exception = None

    if not GOOGLE_API_KEY or not GOOGLE_API_KEY.strip():
        st.error("üö® ERRO: Chave API 'GOOGLE_API_KEY' n√£o encontrada ou vazia nos Segredos do Streamlit.")
        st.stop()
    else:
        try:
            genai.configure(api_key=GOOGLE_API_KEY)
            llm_model_instance = ChatGoogleGenerativeAI(model="gemini-1.5-flash", # ou gemini-pro
                                                       temperature=0.75,
                                                       google_api_key=GOOGLE_API_KEY,
                                                       convert_system_message_to_human=True)
            if 'llm_init_success_sidebar_shown_main_app' not in st.session_state: # Chave √∫nica
                st.sidebar.success("‚úÖ Modelo LLM (Gemini) inicializado!")
                st.session_state.llm_init_success_sidebar_shown_main_app = True
        except Exception as e_llm:
            llm_init_exception = e_llm # Armazena a exce√ß√£o
            st.error(f"üò• ERRO AO INICIALIZAR O MODELO LLM DO GOOGLE: {e_llm}")
            # N√£o vamos dar st.stop() aqui ainda, para permitir que o resto da UI de logout etc. funcione.
            # A verifica√ß√£o de llm_model_instance abaixo cuidar√° disso.

    # --- SEU C√ìDIGO DO APLICATIVO ASSISTENTE PME PRO ---
    if llm_model_instance:
        # --- FUN√á√ïES AUXILIARES PARA MARKETING DIGITAL (Objetivos e Output) ---
        # (Vou usar as suas fun√ß√µes exatamente como voc√™ forneceu)
        def _marketing_get_objective_details(section_key, type_of_creation="post/campanha"):
            st.subheader(f"Detalhes para Orientar a Cria√ß√£o do(a) {type_of_creation.capitalize()}:")
            details = {}
            # Usando APP_KEY_SUFFIX (que √© "_v20_final" do seu c√≥digo)
            details["objective"] = st.text_area(f"Qual o principal objetivo com est(e/a) {type_of_creation}?", key=f"{section_key}_obj{APP_KEY_SUFFIX}")
            details["target_audience"] = st.text_input("Quem voc√™ quer alcan√ßar?", key=f"{section_key}_audience{APP_KEY_SUFFIX}")
            details["product_service"] = st.text_area("Qual produto ou servi√ßo principal voc√™ est√° promovendo?", key=f"{section_key}_product{APP_KEY_SUFFIX}")
            details["key_message"] = st.text_area("Qual mensagem chave voc√™ quer comunicar?", key=f"{section_key}_message{APP_KEY_SUFFIX}")
            details["usp"] = st.text_area("O que torna seu produto/servi√ßo especial (USP)?", key=f"{section_key}_usp{APP_KEY_SUFFIX}")
            details["style_tone"] = st.selectbox("Qual o tom/estilo da comunica√ß√£o?", ("Profissional e direto", "Amig√°vel e informal", "Criativo e inspirador", "Urgente e promocional", "Engra√ßado e leve", "Educacional e informativo"), key=f"{section_key}_tone{APP_KEY_SUFFIX}")
            details["extra_info"] = st.text_area("Alguma informa√ß√£o adicional/CTA?", key=f"{section_key}_extra{APP_KEY_SUFFIX}")
            return details

        def _marketing_display_output_options(generated_content, section_key, file_name_prefix="conteudo_gerado"):
            st.subheader("üéâ Resultado da IA e Pr√≥ximos Passos:")
            st.markdown(generated_content)
            st.download_button(label="üì• Baixar Conte√∫do Gerado", data=generated_content.encode('utf-8'), file_name=f"{file_name_prefix}_{section_key}{APP_KEY_SUFFIX}.txt", mime="text/plain", key=f"download_{section_key}{APP_KEY_SUFFIX}")
            cols_actions = st.columns(2)
            with cols_actions[0]:
                if st.button("üîó Copiar para Compartilhar (Simulado)", key=f"{section_key}_share_btn{APP_KEY_SUFFIX}"):
                    st.success("Conte√∫do pronto para ser copiado e compartilhado nas suas redes ou e-mail!")
                    st.caption("Lembre-se de adaptar para cada plataforma, se necess√°rio.")
            with cols_actions[1]:
                if st.button("üóìÔ∏è Simular Agendamento", key=f"{section_key}_schedule_btn{APP_KEY_SUFFIX}"):
                    st.info("Agendamento simulado. Para agendamento real, use ferramentas como Meta Business Suite, Hootsuite, mLabs, ou a fun√ß√£o de programa√ß√£o do seu servi√ßo de e-mail marketing.")

        # --- HANDLER FUNCTIONS (do seu c√≥digo) ---
        def _marketing_handle_criar_post(uploaded_files_info, details_dict, selected_platforms_list, llm):
            if not selected_platforms_list: st.warning("Por favor, selecione pelo menos uma plataforma."); return
            if not details_dict["objective"]: st.warning("Por favor, descreva o objetivo do post."); return
            with st.spinner("ü§ñ A IA est√° criando seu post... Aguarde!"):
                prompt_parts = [
                    "**Instru√ß√£o para IA:** Voc√™ √© um especialista em copywriting e marketing digital para pequenas e m√©dias empresas no Brasil. Sua tarefa √© criar um post otimizado e engajador para as seguintes plataformas e objetivos. Considere as informa√ß√µes de suporte se fornecidas. Gere apenas o texto do post, com sugest√µes de emojis e hashtags relevantes. Seja conciso e direto ao ponto, adaptando a linguagem para cada plataforma se necess√°rio, mas mantendo a mensagem central. Se multiplas plataformas forem selecionadas, gere uma vers√£o base e sugira pequenas adapta√ß√µes para cada uma se fizer sentido, ou indique que o post pode ser usado de forma similar.",
                    f"**Plataformas Alvo:** {', '.join(selected_platforms_list)}.",
                    f"**Produto/Servi√ßo Principal:** {details_dict['product_service']}",
                    f"**P√∫blico-Alvo:** {details_dict['target_audience']}",
                    f"**Objetivo do Post:** {details_dict['objective']}",
                    f"**Mensagem Chave:** {details_dict['key_message']}",
                    f"**Proposta √önica de Valor (USP):** {details_dict['usp']}",
                    f"**Tom/Estilo:** {details_dict['style_tone']}",
                    f"**Informa√ß√µes Adicionais/CTA:** {details_dict['extra_info']}"
                ] 
                if uploaded_files_info: prompt_parts.append(f"**Informa√ß√µes de Arquivos de Suporte (considere o conte√∫do relevante se aplic√°vel):** {', '.join([f['name'] for f in uploaded_files_info])}.")
                final_prompt = "\n\n".join(prompt_parts)
                ai_response = llm.invoke(HumanMessage(content=final_prompt))
                st.session_state[f'generated_post_content_new{APP_KEY_SUFFIX}'] = ai_response.content # Chave de session_state atualizada

        def _marketing_handle_criar_campanha(uploaded_files_info, details_dict, campaign_specifics, selected_platforms_list, llm):
            if not selected_platforms_list: st.warning("Por favor, selecione pelo menos uma plataforma."); return
            if not details_dict["objective"]: st.warning("Por favor, descreva o objetivo da campanha."); return
            with st.spinner("üß† A IA est√° elaborando seu plano de campanha..."):
                prompt_parts = [
                    "**Instru√ß√£o para IA:** Voc√™ √© um estrategista de marketing digital experiente, focado em PMEs no Brasil. Desenvolva um plano de campanha de marketing conciso e acion√°vel com base nas informa√ß√µes fornecidas. O plano deve incluir: 1. Conceito da Campanha (Tema Central). 2. Sugest√µes de Conte√∫do Chave para cada plataforma selecionada. 3. Um cronograma geral sugerido (Ex: Semana 1 - Teaser, Semana 2 - Lan√ßamento, etc.). 4. M√©tricas chave para acompanhar o sucesso. Considere as informa√ß√µes de suporte, se fornecidas.",
                    f"**Nome da Campanha:** {campaign_specifics['name']}",
                    f"**Plataformas Alvo:** {', '.join(selected_platforms_list)}.",
                    f"**Produto/Servi√ßo Principal da Campanha:** {details_dict['product_service']}",
                    f"**P√∫blico-Alvo da Campanha:** {details_dict['target_audience']}",
                    f"**Objetivo Principal da Campanha:** {details_dict['objective']}",
                    f"**Mensagem Chave da Campanha:** {details_dict['key_message']}",
                    f"**USP do Produto/Servi√ßo na Campanha:** {details_dict['usp']}",
                    f"**Tom/Estilo da Campanha:** {details_dict['style_tone']}",
                    f"**Dura√ß√£o Estimada:** {campaign_specifics['duration']}",
                    f"**Or√ßamento Aproximado (se informado):** {campaign_specifics['budget']}",
                    f"**KPIs mais importantes:** {campaign_specifics['kpis']}",
                    f"**Informa√ß√µes Adicionais/CTA da Campanha:** {details_dict['extra_info']}"
                ] 
                if uploaded_files_info: prompt_parts.append(f"**Informa√ß√µes de Arquivos de Suporte (considere o conte√∫do relevante se aplic√°vel):** {', '.join([f['name'] for f in uploaded_files_info])}.")
                final_prompt = "\n\n".join(prompt_parts)
                ai_response = llm.invoke(HumanMessage(content=final_prompt))
                st.session_state[f'generated_campaign_content_new{APP_KEY_SUFFIX}'] = ai_response.content # Chave de session_state atualizada

        def _marketing_handle_criar_landing_page(uploaded_files_info, lp_details, llm):
            if not lp_details["purpose"] or not lp_details["main_offer"] or not lp_details["cta"]: st.warning("Por favor, preencha objetivo, oferta e CTA."); return
            with st.spinner("üé® A IA est√° desenhando a estrutura da sua landing page..."):
                prompt_parts = [
                    "**Instru√ß√£o para IA:** Voc√™ √© um especialista em UX/UI e copywriting para landing pages de alta convers√£o, com foco em PMEs no Brasil. Baseado nos detalhes fornecidos, crie uma estrutura detalhada e sugest√µes de texto (copy) para cada se√ß√£o de uma landing page. Inclua se√ß√µes como: Cabe√ßalho (Headline, Sub-headline), Problema/Dor, Apresenta√ß√£o da Solu√ß√£o/Produto, Benef√≠cios Chave, Prova Social (Depoimentos), Oferta Irresist√≠vel, Chamada para A√ß√£o (CTA) clara e forte, Garantia (se aplic√°vel), FAQ. Considere as informa√ß√µes de suporte, se fornecidas.",
                    f"**Objetivo da Landing Page:** {lp_details['purpose']}",
                    f"**P√∫blico-Alvo (Persona):** {lp_details['target_audience']}",
                    f"**Oferta Principal:** {lp_details['main_offer']}",
                    f"**Principais Benef√≠cios/Transforma√ß√µes da Oferta:** {lp_details['key_benefits']}",
                    f"**Chamada para A√ß√£o (CTA) Principal:** {lp_details['cta']}",
                    f"**Prefer√™ncias Visuais/Refer√™ncias (se houver):** {lp_details['visual_prefs']}"
                ]
                if uploaded_files_info: prompt_parts.append(f"**Informa√ß√µes de Arquivos de Suporte (considere o conte√∫do relevante se aplic√°vel):** {', '.join([f['name'] for f in uploaded_files_info])}.")
                final_prompt = "\n\n".join(prompt_parts)
                ai_response = llm.invoke(HumanMessage(content=final_prompt))
                st.session_state[f'generated_lp_content_new{APP_KEY_SUFFIX}'] = ai_response.content # Chave de session_state atualizada

        def _marketing_handle_criar_site(uploaded_files_info, site_details, llm):
            if not site_details["business_type"] or not site_details["main_purpose"]: st.warning("Informe tipo de neg√≥cio e objetivo do site."); return
            with st.spinner("üõ†Ô∏è A IA est√° arquitetando a estrutura do seu site..."):
                prompt_parts = [
                    "**Instru√ß√£o para IA:** Voc√™ √© um arquiteto de informa√ß√£o e web designer experiente, focado em criar sites eficazes para PMEs no Brasil. Desenvolva uma proposta de estrutura de site (mapa do site com principais p√°ginas e se√ß√µes dentro de cada p√°gina) e sugest√µes de conte√∫do chave para cada se√ß√£o. Considere as informa√ß√µes de suporte, se fornecidas.",
                    f"**Tipo de Neg√≥cio/Empresa:** {site_details['business_type']}",
                    f"**Principal Objetivo do Site:** {site_details['main_purpose']}",
                    f"**P√∫blico-Alvo Principal:** {site_details['target_audience']}",
                    f"**P√°ginas Essenciais Desejadas:** {site_details['essential_pages']}",
                    f"**Principais Produtos/Servi√ßos/Diferenciais a serem destacados:** {site_details['key_features']}",
                    f"**Personalidade da Marca:** {site_details['brand_personality']}",
                    f"**Prefer√™ncias Visuais/Refer√™ncias (se houver):** {site_details['visual_references']}"
                ]
                if uploaded_files_info: prompt_parts.append(f"**Informa√ß√µes de Arquivos de Suporte (considere o conte√∫do relevante se aplic√°vel):** {', '.join([f['name'] for f in uploaded_files_info])}.")
                final_prompt = "\n\n".join(prompt_parts)
                ai_response = llm.invoke(HumanMessage(content=final_prompt))
                st.session_state[f'generated_site_content_new{APP_KEY_SUFFIX}'] = ai_response.content # Chave de session_state atualizada

        def _marketing_handle_encontre_cliente(uploaded_files_info, client_details, llm):
            if not client_details["product_campaign"]: st.warning("Descreva o produto/servi√ßo ou campanha."); return
            with st.spinner("üïµÔ∏è A IA est√° investigando seu p√∫blico-alvo..."):
                prompt_parts = [
                    "**Instru√ß√£o para IA:** Voc√™ √© um 'Agente Detetive de Clientes', especialista em marketing e pesquisa de mercado para PMEs no Brasil. Sua tarefa √© realizar uma an√°lise completa do p√∫blico-alvo com base nas informa√ß√µes fornecidas e gerar um relat√≥rio detalhado com os seguintes itens: 1. Persona Detalhada (Nome fict√≠cio, Idade, Profiss√£o, Dores, Necessidades, Sonhos, Onde busca informa√ß√£o). 2. Sugest√µes de Canais de Marketing mais eficazes para alcan√ßar essa persona. 3. Sugest√µes de Mensagens Chave e √Çngulos de Comunica√ß√£o que ressoem com essa persona. 4. Se 'Deep Research' estiver ativado, inclua insights adicionais sobre comportamento online, tend√™ncias e micro-segmentos. Considere as informa√ß√µes de suporte, se fornecidas.",
                    f"**Produto/Servi√ßo ou Campanha para An√°lise:** {client_details['product_campaign']}",
                    f"**Localiza√ß√£o Geogr√°fica (Cidade(s), Regi√£o):** {client_details['location']}",
                    f"**Verba Aproximada para A√ß√£o/Campanha (se aplic√°vel):** {client_details['budget']}",
                    f"**Faixa Et√°ria e G√™nero Predominante (se souber):** {client_details['age_gender']}",
                    f"**Principais Interesses, Hobbies, Dores, Necessidades do P√∫blico Desejado:** {client_details['interests']}",
                    f"**Canais de Marketing que j√° utiliza ou considera:** {client_details['current_channels']}",
                    f"**N√≠vel de Pesquisa:** {'Deep Research Ativado (an√°lise mais aprofundada)' if client_details['deep_research'] else 'Pesquisa Padr√£o'}"
                ]
                if uploaded_files_info: prompt_parts.append(f"**Informa√ß√µes de Arquivos de Suporte (considere o conte√∫do relevante se aplic√°vel):** {', '.join([f['name'] for f in uploaded_files_info])}.")
                final_prompt = "\n\n".join(prompt_parts)
                ai_response = llm.invoke(HumanMessage(content=final_prompt))
                st.session_state[f'generated_client_analysis_new{APP_KEY_SUFFIX}'] = ai_response.content # Chave de session_state atualizada

        def _marketing_handle_conheca_concorrencia(uploaded_files_info, competitor_details, llm):
            if not competitor_details["your_business"] or not competitor_details["competitors_list"]: st.warning("Descreva seu neg√≥cio e liste concorrentes."); return
            with st.spinner("üî¨ A IA est√° analisando a concorr√™ncia..."):
                prompt_parts = [
                    "**Instru√ß√£o para IA:** Voc√™ √© um 'Agente de Intelig√™ncia Competitiva', especialista em an√°lise de mercado para PMEs no Brasil. Com base nas informa√ß√µes do neg√≥cio do usu√°rio e da lista de concorrentes, elabore um relat√≥rio breve e √∫til. Para cada concorrente listado (ou os principais, se a lista for longa), analise os 'Aspectos para An√°lise' selecionados. Destaque os pontos fortes e fracos de cada um em rela√ß√£o a esses aspectos e, ao final, sugira 2-3 oportunidades ou diferenciais que o neg√≥cio do usu√°rio pode explorar. Considere as informa√ß√µes de suporte, se fornecidas.",
                    f"**Neg√≥cio do Usu√°rio (para compara√ß√£o):** {competitor_details['your_business']}",
                    f"**Concorrentes (nomes, sites, redes sociais, se poss√≠vel):** {competitor_details['competitors_list']}",
                    f"**Aspectos para An√°lise:** {', '.join(competitor_details['aspects_to_analyze'])}"
                ]
                if uploaded_files_info: prompt_parts.append(f"**Informa√ß√µes de Arquivos de Suporte (considere o conte√∫do relevante se aplic√°vel):** {', '.join([f['name'] for f in uploaded_files_info])}.")
                final_prompt = "\n\n".join(prompt_parts)
                ai_response = llm.invoke(HumanMessage(content=final_prompt))
                st.session_state[f'generated_competitor_analysis_new{APP_KEY_SUFFIX}'] = ai_response.content # Chave de session_state atualizada

        # --- Classe do Agente (AssistentePMEPro) (do seu c√≥digo) ---
        class AssistentePMEPro:
            def __init__(self, llm_passed_model):
                if llm_passed_model is None:
                    st.error("‚ùå Erro cr√≠tico: Agente PME Pro tentou ser inicializado sem um modelo LLM.")
                    st.stop() 
                self.llm = llm_passed_model
                # Usando APP_KEY_SUFFIX para chaves de mem√≥ria
                if f'memoria_plano_negocios{APP_KEY_SUFFIX}' not in st.session_state:
                    st.session_state[f'memoria_plano_negocios{APP_KEY_SUFFIX}'] = ConversationBufferMemory(memory_key=f"historico_chat_plano{APP_KEY_SUFFIX}", return_messages=True)
                if f'memoria_calculo_precos{APP_KEY_SUFFIX}' not in st.session_state:
                    st.session_state[f'memoria_calculo_precos{APP_KEY_SUFFIX}'] = ConversationBufferMemory(memory_key=f"historico_chat_precos{APP_KEY_SUFFIX}", return_messages=True)
                if f'memoria_gerador_ideias{APP_KEY_SUFFIX}' not in st.session_state:
                    st.session_state[f'memoria_gerador_ideias{APP_KEY_SUFFIX}'] = ConversationBufferMemory(memory_key=f"historico_chat_ideias{APP_KEY_SUFFIX}", return_messages=True)
                
                self.memoria_plano_negocios = st.session_state[f'memoria_plano_negocios{APP_KEY_SUFFIX}']
                self.memoria_calculo_precos = st.session_state[f'memoria_calculo_precos{APP_KEY_SUFFIX}']
                self.memoria_gerador_ideias = st.session_state[f'memoria_gerador_ideias{APP_KEY_SUFFIX}']

            def _criar_cadeia_conversacional(self, system_message_content, memoria_especifica, memory_key_placeholder_base="historico_chat"):
                actual_memory_key = memoria_especifica.memory_key # Usa a memory_key da inst√¢ncia de mem√≥ria
                prompt_template = ChatPromptTemplate.from_messages([
                    SystemMessagePromptTemplate.from_template(system_message_content),
                    MessagesPlaceholder(variable_name=actual_memory_key),
                    HumanMessagePromptTemplate.from_template("{input_usuario}")
                ])
                return LLMChain(llm=self.llm, prompt=prompt_template, memory=memoria_especifica, verbose=False)

            def marketing_digital_guiado(self):
                st.header("üöÄ Marketing Digital Interativo com IA")
                st.caption("Seu copiloto para criar estrat√©gias, posts, campanhas e mais!")
                st.markdown("---")

                marketing_files_info_for_prompt_local = [] 
                with st.sidebar: 
                    # Este file_uploader j√° estava na sua vers√£o, vou manter o sufixo dele se n√£o conflitar
                    # Mas idealmente, deveria usar APP_KEY_SUFFIX
                    st.subheader("üìé Suporte para Marketing") # Esta subheader pode ser movida para o corpo principal se preferir
                    uploaded_marketing_files = st.file_uploader(
                        "Upload de arquivos de CONTEXTO para Marketing (opcional):", 
                        accept_multiple_files=True,
                        type=['png', 'jpg', 'jpeg', 'txt', 'md', 'pdf', 'csv', 'xlsx', 'docx', 'pptx'], 
                        key=f"marketing_files_uploader{APP_KEY_SUFFIX}" # Aplicando sufixo
                    )
                    if uploaded_marketing_files:
                        temp_marketing_files_info = []
                        for up_file in uploaded_marketing_files:
                            temp_marketing_files_info.append({"name": up_file.name, "type": up_file.type, "size": up_file.size})
                        if temp_marketing_files_info:
                            marketing_files_info_for_prompt_local = temp_marketing_files_info 
                            st.success(f"{len(uploaded_marketing_files)} arquivo(s) de contexto carregado(s)!")
                            with st.expander("Ver arquivos de contexto"):
                                for finfo in marketing_files_info_for_prompt_local:
                                    st.write(f"- {finfo['name']} ({finfo['type']})")
                    # st.markdown("---") # Removendo este divisor da sidebar, o layout principal do app j√° tem um

                main_action_key = f"main_marketing_action_choice{APP_KEY_SUFFIX}" # Aplicando sufixo
                opcoes_menu_marketing_dict = { 
                    "Selecione uma op√ß√£o...": 0,
                    "1 - Criar post para redes sociais ou e-mail": 1,
                    "2 - Criar campanha de marketing completa": 2,
                    "3 - Criar estrutura e conte√∫do para landing page": 3,
                    "4 - Criar estrutura e conte√∫do para site com IA": 4,
                    "5 - Encontrar meu cliente ideal (An√°lise de P√∫blico-Alvo)": 5,
                    "6 - Conhecer a concorr√™ncia (An√°lise Competitiva)": 6
                }
                opcoes_radio_marketing = list(opcoes_menu_marketing_dict.keys())
                
                # Gerenciamento do √≠ndice do radio button
                radio_index_key = f"{main_action_key}_index"
                if radio_index_key not in st.session_state:
                    st.session_state[radio_index_key] = 0

                def update_marketing_radio_index_on_change(): # Fun√ß√£o de callback precisa existir
                    st.session_state[radio_index_key] = opcoes_radio_marketing.index(st.session_state[main_action_key])

                main_action = st.radio(
                    "Ol√°! O que voc√™ quer fazer agora em marketing digital?",
                    opcoes_radio_marketing,
                    index=st.session_state[radio_index_key], 
                    key=main_action_key,
                    on_change=update_marketing_radio_index_on_change # Corrigido para on_change
                )
                st.markdown("---")
                
                platforms_config_options = { 
                    "Instagram": "insta", "Facebook": "fb", "X (Twitter)": "x", "WhatsApp": "wpp", 
                    "TikTok": "tt", "Kwai": "kwai", "YouTube (descri√ß√£o/roteiro)": "yt",
                    "E-mail Marketing (lista pr√≥pria)": "email_own", 
                    "E-mail Marketing (Campanha Google Ads)": "email_google"
                }

                if main_action == "1 - Criar post para redes sociais ou e-mail":
                    st.subheader("‚ú® Criador de Posts com IA")
                    with st.form(f"post_creator_form{APP_KEY_SUFFIX}"):
                        st.subheader(" Plataformas Desejadas:")
                        key_select_all_post = f"post_select_all{APP_KEY_SUFFIX}"
                        select_all_post_checked = st.checkbox("Selecionar Todas as Plataformas Acima", key=key_select_all_post)
                        cols_post = st.columns(2); selected_platforms_post_ui = []
                        for i, (platform_name, platform_suffix) in enumerate(platforms_config_options.items()):
                            col_index = i % 2
                            platform_key = f"post_platform_{platform_suffix}{APP_KEY_SUFFIX}" 
                            with cols_post[col_index]:
                                if st.checkbox(platform_name, key=platform_key, value=select_all_post_checked):
                                    selected_platforms_post_ui.append(platform_name)
                                if "E-mail Marketing" in platform_name and st.session_state.get(platform_key): 
                                    st.caption("üí° Para e-mail marketing, considere segmentar sua lista e personalizar a sauda√ß√£o.")
                        post_details = _marketing_get_objective_details(f"post{APP_KEY_SUFFIX}", "post") # Usando section_key mais simples
                        submit_button_pressed_post = st.form_submit_button("üí° Gerar Post!")
                    if submit_button_pressed_post:
                        _marketing_handle_criar_post(marketing_files_info_for_prompt_local, post_details, selected_platforms_post_ui, self.llm)
                    if f'generated_post_content_new{APP_KEY_SUFFIX}' in st.session_state: # Usando chave de session_state correta
                        _marketing_display_output_options(st.session_state[f'generated_post_content_new{APP_KEY_SUFFIX}'], f"post_output{APP_KEY_SUFFIX}", "post_ia")

                elif main_action == "2 - Criar campanha de marketing completa":
                    st.subheader("üåç Planejador de Campanhas de Marketing com IA")
                    with st.form(f"campaign_creator_form{APP_KEY_SUFFIX}"):
                        campaign_name = st.text_input("Nome da Campanha:", key=f"campaign_name{APP_KEY_SUFFIX}")
                        st.subheader(" Plataformas Desejadas:")
                        key_select_all_camp = f"campaign_select_all{APP_KEY_SUFFIX}"
                        select_all_camp_checked = st.checkbox("Selecionar Todas as Plataformas Acima", key=key_select_all_camp)
                        cols_camp = st.columns(2); selected_platforms_camp_ui = []
                        for i, (platform_name, platform_suffix) in enumerate(platforms_config_options.items()):
                            col_index = i % 2
                            platform_key = f"campaign_platform_{platform_suffix}{APP_KEY_SUFFIX}"
                            with cols_camp[col_index]:
                                if st.checkbox(platform_name, key=platform_key, value=select_all_camp_checked):
                                    selected_platforms_camp_ui.append(platform_name)
                        campaign_details_obj = _marketing_get_objective_details(f"campaign{APP_KEY_SUFFIX}", "campanha")
                        campaign_duration = st.text_input("Dura√ß√£o Estimada:", key=f"campaign_duration{APP_KEY_SUFFIX}")
                        campaign_budget_approx = st.text_input("Or√ßamento Aproximado (opcional):", key=f"campaign_budget{APP_KEY_SUFFIX}")
                        specific_kpis = st.text_area("KPIs mais importantes:", key=f"campaign_kpis{APP_KEY_SUFFIX}")
                        submit_button_pressed_camp = st.form_submit_button("üöÄ Gerar Plano de Campanha!")
                    if submit_button_pressed_camp:
                        campaign_specifics_dict = {"name": campaign_name, "duration": campaign_duration, "budget": campaign_budget_approx, "kpis": specific_kpis}
                        _marketing_handle_criar_campanha(marketing_files_info_for_prompt_local, campaign_details_obj, campaign_specifics_dict, selected_platforms_camp_ui, self.llm)
                    if f'generated_campaign_content_new{APP_KEY_SUFFIX}' in st.session_state: # Usando chave de session_state correta
                        _marketing_display_output_options(st.session_state[f'generated_campaign_content_new{APP_KEY_SUFFIX}'], f"campaign_output{APP_KEY_SUFFIX}", "campanha_ia")
                
                elif main_action == "3 - Criar estrutura e conte√∫do para landing page":
                    st.subheader("üìÑ Gerador de Estrutura para Landing Pages com IA")
                    with st.form(f"landing_page_form{APP_KEY_SUFFIX}"):
                        lp_purpose = st.text_input("Principal objetivo da landing page:", key=f"lp_purpose{APP_KEY_SUFFIX}")
                        lp_target_audience = st.text_input("Para quem √© esta landing page? (Persona)", key=f"lp_audience{APP_KEY_SUFFIX}")
                        lp_main_offer = st.text_area("Oferta principal e irresist√≠vel:", key=f"lp_offer{APP_KEY_SUFFIX}")
                        lp_key_benefits = st.text_area("3-5 principais benef√≠cios/transforma√ß√µes:", key=f"lp_benefits{APP_KEY_SUFFIX}")
                        lp_cta = st.text_input("Chamada para a√ß√£o (CTA) principal:", key=f"lp_cta{APP_KEY_SUFFIX}")
                        lp_visual_prefs = st.text_input("Prefer√™ncia de cores, estilo visual ou sites de refer√™ncia? (Opcional)", key=f"lp_visual{APP_KEY_SUFFIX}")
                        submitted_lp = st.form_submit_button("üõ†Ô∏è Gerar Estrutura da LP!")
                    if submitted_lp:
                        lp_details_dict = {"purpose": lp_purpose, "target_audience": lp_target_audience, "main_offer": lp_main_offer, "key_benefits": lp_key_benefits, "cta": lp_cta, "visual_prefs": lp_visual_prefs}
                        _marketing_handle_criar_landing_page(marketing_files_info_for_prompt_local, lp_details_dict, self.llm)
                    if f'generated_lp_content_new{APP_KEY_SUFFIX}' in st.session_state: # Usando chave de session_state correta
                        st.subheader("üí° Estrutura e Conte√∫do Sugeridos para Landing Page:")
                        st.markdown(st.session_state[f'generated_lp_content_new{APP_KEY_SUFFIX}'])
                        st.download_button(label="üì• Baixar Sugest√µes da LP",data=st.session_state[f'generated_lp_content_new{APP_KEY_SUFFIX}'].encode('utf-8'), file_name=f"landing_page_sugestoes_ia{APP_KEY_SUFFIX}.txt", mime="text/plain", key=f"download_lp{APP_KEY_SUFFIX}") 

                elif main_action == "4 - Criar estrutura e conte√∫do para site com IA":
                    st.subheader("üèóÔ∏è Arquiteto de Sites com IA")
                    with st.form(f"site_creator_form{APP_KEY_SUFFIX}"): 
                        site_business_type = st.text_input("Tipo do seu neg√≥cio/empresa:", key=f"site_biz_type{APP_KEY_SUFFIX}")
                        site_main_purpose = st.text_area("Principal objetivo do seu site:", key=f"site_purpose{APP_KEY_SUFFIX}")
                        site_target_audience = st.text_input("P√∫blico principal do site:", key=f"site_audience{APP_KEY_SUFFIX}")
                        site_essential_pages = st.text_area("P√°ginas essenciais (Ex: Home, Sobre, Servi√ßos):", key=f"site_pages{APP_KEY_SUFFIX}")
                        site_key_features = st.text_area("Principais produtos/servi√ßos/diferenciais:", key=f"site_features{APP_KEY_SUFFIX}")
                        site_brand_personality = st.text_input("Personalidade da sua marca:", key=f"site_brand{APP_KEY_SUFFIX}")
                        site_visual_references = st.text_input("Prefer√™ncias de cores, estilo ou sites de refer√™ncia? (Opcional)", key=f"site_visual_ref{APP_KEY_SUFFIX}")
                        submitted_site = st.form_submit_button("üèõÔ∏è Gerar Estrutura do Site!")
                    if submitted_site:
                        site_details_dict = {"business_type": site_business_type, "main_purpose": site_main_purpose, "target_audience": site_target_audience, "essential_pages": site_essential_pages, "key_features": site_key_features, "brand_personality": site_brand_personality, "visual_references": site_visual_references}
                        _marketing_handle_criar_site(marketing_files_info_for_prompt_local, site_details_dict, self.llm)
                    if f'generated_site_content_new{APP_KEY_SUFFIX}' in st.session_state: # Usando chave de session_state correta
                        st.subheader("üèõÔ∏è Estrutura e Conte√∫do Sugeridos para o Site:")
                        st.markdown(st.session_state[f'generated_site_content_new{APP_KEY_SUFFIX}'])
                        st.download_button(label="üì• Baixar Sugest√µes do Site",data=st.session_state[f'generated_site_content_new{APP_KEY_SUFFIX}'].encode('utf-8'), file_name=f"site_sugestoes_ia{APP_KEY_SUFFIX}.txt", mime="text/plain",key=f"download_site{APP_KEY_SUFFIX}")

                elif main_action == "5 - Encontrar meu cliente ideal (An√°lise de P√∫blico-Alvo)":
                    st.subheader("üéØ Decodificador de Clientes com IA")
                    with st.form(f"find_client_form{APP_KEY_SUFFIX}"):
                        fc_product_campaign = st.text_area("Produto/servi√ßo ou campanha para an√°lise:", key=f"fc_campaign{APP_KEY_SUFFIX}")
                        fc_location = st.text_input("Cidade(s) ou regi√£o de alcance:", key=f"fc_location{APP_KEY_SUFFIX}")
                        fc_budget = st.text_input("Verba aproximada para a√ß√£o/campanha? (Opcional)", key=f"fc_budget{APP_KEY_SUFFIX}")
                        fc_age_gender = st.text_input("Faixa et√°ria e g√™nero predominante:", key=f"fc_age_gender{APP_KEY_SUFFIX}")
                        fc_interests = st.text_area("Principais interesses, hobbies, dores, necessidades:", key=f"fc_interests{APP_KEY_SUFFIX}")
                        fc_current_channels = st.text_area("Canais de marketing que j√° utiliza ou considera:", key=f"fc_channels{APP_KEY_SUFFIX}")
                        fc_deep_research = st.checkbox("Habilitar 'Deep Research' (an√°lise mais aprofundada pela IA)", key=f"fc_deep{APP_KEY_SUFFIX}")
                        submitted_fc = st.form_submit_button("üîç Encontrar Meu Cliente!")
                    if submitted_fc:
                        client_details_dict = {"product_campaign": fc_product_campaign, "location": fc_location, "budget": fc_budget, "age_gender": fc_age_gender, "interests": fc_interests, "current_channels": fc_current_channels, "deep_research": fc_deep_research}
                        _marketing_handle_encontre_cliente(marketing_files_info_for_prompt_local, client_details_dict, self.llm)
                    if f'generated_client_analysis_new{APP_KEY_SUFFIX}' in st.session_state: # Usando chave de session_state correta
                        st.subheader("üïµÔ∏è‚Äç‚ôÇÔ∏è An√°lise de P√∫blico-Alvo e Recomenda√ß√µes:")
                        st.markdown(st.session_state[f'generated_client_analysis_new{APP_KEY_SUFFIX}'])
                        st.download_button(label="üì• Baixar An√°lise de P√∫blico",data=st.session_state[f'generated_client_analysis_new{APP_KEY_SUFFIX}'].encode('utf-8'), file_name=f"analise_publico_alvo_ia{APP_KEY_SUFFIX}.txt", mime="text/plain",key=f"download_client_analysis{APP_KEY_SUFFIX}")
                
                elif main_action == "6 - Conhecer a concorr√™ncia (An√°lise Competitiva)":
                    st.subheader("üßê Radar da Concorr√™ncia com IA")
                    with st.form(f"competitor_analysis_form{APP_KEY_SUFFIX}"):
                        ca_your_business = st.text_area("Descreva seu pr√≥prio neg√≥cio/produto para compara√ß√£o:", key=f"ca_your_biz{APP_KEY_SUFFIX}")
                        ca_competitors_list = st.text_area("Liste seus principais concorrentes (nomes, sites, redes sociais):", key=f"ca_competitors{APP_KEY_SUFFIX}")
                        ca_aspects_to_analyze = st.multiselect( "Quais aspectos da concorr√™ncia analisar?", ["Presen√ßa Online", "Tipos de Conte√∫do", "Comunica√ß√£o", "Pontos Fortes", "Pontos Fracos", "Pre√ßos (se observ√°vel)", "Engajamento"], default=["Presen√ßa Online", "Pontos Fortes", "Pontos Fracos"], key=f"ca_aspects{APP_KEY_SUFFIX}")
                        submitted_ca = st.form_submit_button("üì° Analisar Concorrentes!")
                    if submitted_ca:
                        competitor_details_dict = {"your_business": ca_your_business, "competitors_list": ca_competitors_list, "aspects_to_analyze": ca_aspects_to_analyze}
                        _marketing_handle_conheca_concorrencia(marketing_files_info_for_prompt_local, competitor_details_dict, self.llm)
                    if f'generated_competitor_analysis_new{APP_KEY_SUFFIX}' in st.session_state: # Usando chave de session_state correta
                        st.subheader("üìä An√°lise da Concorr√™ncia e Insights:")
                        st.markdown(st.session_state[f'generated_competitor_analysis_new{APP_KEY_SUFFIX}'])
                        st.download_button(label="üì• Baixar An√°lise da Concorr√™ncia", data=st.session_state[f'generated_competitor_analysis_new{APP_KEY_SUFFIX}'].encode('utf-8'), file_name=f"analise_concorrencia_ia{APP_KEY_SUFFIX}.txt",mime="text/plain",key=f"download_competitor_analysis{APP_KEY_SUFFIX}")

                elif main_action == "Selecione uma op√ß√£o...":
                    st.info("üëã Bem-vindo √† se√ß√£o interativa de Marketing Digital com IA! Escolha uma das op√ß√µes acima para come√ßar.")
                    # Usando o caminho corrigido para o logo local aqui tamb√©m
                    LOGO_PATH_MARKETING_WELCOME = "images/logo-pme-ia.png"
                    FALLBACK_LOGO_MARKETING_WELCOME = "https://i.imgur.com/7IIYxq1.png"
                    try:
                        st.image(LOGO_PATH_MARKETING_WELCOME, caption="Assistente PME Pro", width=200)
                    except Exception:
                        st.image(FALLBACK_LOGO_MARKETING_WELCOME, caption="Assistente PME Pro (Fallback)", width=200)
            
            # Demais m√©todos da classe AssistentePMEPro (conversar_plano_de_negocios, etc.)
            # com as adapta√ß√µes de memory_key e outras chaves para APP_KEY_SUFFIX

        # --- Fun√ß√µes Utilit√°rias de Chat (do seu c√≥digo, adaptando chaves para APP_KEY_SUFFIX) ---
        def inicializar_ou_resetar_chat(area_chave, mensagem_inicial_ia, memoria_agente_instancia):
            chat_display_key = f"chat_display_{area_chave}{APP_KEY_SUFFIX}" # Usando APP_KEY_SUFFIX
            st.session_state[chat_display_key] = [{"role": "assistant", "content": mensagem_inicial_ia}]
            if memoria_agente_instancia:
                memoria_agente_instancia.clear()
                if hasattr(memoria_agente_instancia.chat_memory, 'add_ai_message'):
                    memoria_agente_instancia.chat_memory.add_ai_message(mensagem_inicial_ia)
                elif hasattr(memoria_agente_instancia.chat_memory, 'messages') and isinstance(memoria_agente_instancia.chat_memory.messages, list):
                     # Para ConversationBufferMemory, a forma correta pode ser adicionar diretamente √† lista messages
                    memoria_agente_instancia.chat_memory.messages.clear() # Limpa primeiro
                    memoria_agente_instancia.chat_memory.messages.append(AIMessage(content=mensagem_inicial_ia))
            # Limpando chaves espec√≠ficas de upload
            if area_chave == "calculo_precos": 
                st.session_state.pop(f'last_uploaded_image_info_{area_chave}{APP_KEY_SUFFIX}', None)
                st.session_state.pop(f'processed_image_id_{area_chave}{APP_KEY_SUFFIX}', None)
                st.session_state.pop(f'user_input_processed_{area_chave}{APP_KEY_SUFFIX}', None)
            elif area_chave == "gerador_ideias": 
                st.session_state.pop(f'uploaded_file_info_{area_chave}_for_prompt{APP_KEY_SUFFIX}', None)
                st.session_state.pop(f'processed_file_id_{area_chave}{APP_KEY_SUFFIX}', None)
                st.session_state.pop(f'user_input_processed_{area_chave}{APP_KEY_SUFFIX}', None)

        def exibir_chat_e_obter_input(area_chave, prompt_placeholder, funcao_conversa_agente, **kwargs_funcao_agente):
            chat_display_key = f"chat_display_{area_chave}{APP_KEY_SUFFIX}" # Usando APP_KEY_SUFFIX
            if chat_display_key not in st.session_state: 
                st.session_state[chat_display_key] = [] 
            for msg_info in st.session_state[chat_display_key]:
                with st.chat_message(msg_info["role"]): 
                    st.markdown(msg_info["content"])
            prompt_usuario = st.chat_input(prompt_placeholder, key=f"chat_input_{area_chave}{APP_KEY_SUFFIX}") # Usando APP_KEY_SUFFIX
            if prompt_usuario:
                st.session_state[chat_display_key].append({"role": "user", "content": prompt_usuario})
                with st.chat_message("user"): st.markdown(prompt_usuario)
                if area_chave in ["calculo_precos", "gerador_ideias"]: st.session_state[f'user_input_processed_{area_chave}{APP_KEY_SUFFIX}'] = True # Usando APP_KEY_SUFFIX
                with st.spinner("Assistente PME Pro est√° processando... ü§î"):
                    resposta_ai = funcao_conversa_agente(prompt_usuario, **kwargs_funcao_agente)
                st.session_state[chat_display_key].append({"role": "assistant", "content": resposta_ai})
                st.rerun()
        
        def _sidebar_clear_button(label, memoria, section_key): # Removido key_suffix_version, usar√° APP_KEY_SUFFIX
            if st.sidebar.button(f"üóëÔ∏è Limpar Hist√≥rico de {label}", key=f"btn_reset_{section_key}{APP_KEY_SUFFIX}_clear"): # Usando APP_KEY_SUFFIX
                msg_inicial = f"Ok, vamos recome√ßar {label.lower()}! Qual o seu ponto de partida?"
                if section_key == "calculo_precos": msg_inicial = "Ok, vamos recome√ßar o c√°lculo de pre√ßos! Descreva seu produto ou servi√ßo."
                elif section_key == "gerador_ideias": msg_inicial = "Ok, vamos recome√ßar a gera√ß√£o de ideias! Qual o seu ponto de partida?"
                inicializar_ou_resetar_chat(section_key, msg_inicial, memoria) 
                st.rerun()

        def _handle_chat_with_image(area_chave, prompt_placeholder, funcao_conversa_agente, uploaded_image_obj): # Removido key_suffix_version
            # Usando APP_KEY_SUFFIX implicitamente nas chaves de session_state
            descricao_imagem_para_ia = None
            processed_image_id_key = f'processed_image_id_{area_chave}{APP_KEY_SUFFIX}'
            last_uploaded_info_key = f'last_uploaded_image_info_{area_chave}{APP_KEY_SUFFIX}'
            user_input_processed_key = f'user_input_processed_{area_chave}{APP_KEY_SUFFIX}'

            if uploaded_image_obj is not None:
                # Usar uploaded_image_obj.file_id para garantir unicidade se o mesmo nome de arquivo for reenviado
                if st.session_state.get(processed_image_id_key) != uploaded_image_obj.file_id:
                    try:
                        img_pil = Image.open(uploaded_image_obj); st.image(img_pil, caption=f"Imagem: {uploaded_image_obj.name}", width=150)
                        descricao_imagem_para_ia = f"Usu√°rio carregou imagem '{uploaded_image_obj.name}'."
                        st.session_state[last_uploaded_info_key] = descricao_imagem_para_ia
                        st.session_state[processed_image_id_key] = uploaded_image_obj.file_id # Armazenar file_id
                        st.info(f"Imagem '{uploaded_image_obj.name}' pronta para o di√°logo.")
                    except Exception as e_img_proc: st.error(f"Erro ao processar imagem: {e_img_proc}"); st.session_state[last_uploaded_info_key] = None; st.session_state[processed_image_id_key] = None
                else: descricao_imagem_para_ia = st.session_state.get(last_uploaded_info_key)
            kwargs_chat = {}
            ctx_img_prox_dialogo = st.session_state.get(last_uploaded_info_key)
            if ctx_img_prox_dialogo and not st.session_state.get(user_input_processed_key, False): kwargs_chat['descricao_imagem_contexto'] = ctx_img_prox_dialogo
            exibir_chat_e_obter_input(area_chave, prompt_placeholder, funcao_conversa_agente, **kwargs_chat)
            if user_input_processed_key in st.session_state and st.session_state[user_input_processed_key]:
                if st.session_state.get(last_uploaded_info_key): st.session_state[last_uploaded_info_key] = None
                st.session_state[user_input_processed_key] = False

        def _handle_chat_with_files(area_chave, prompt_placeholder, funcao_conversa_agente, uploaded_files_objs): # Removido key_suffix_version
            # Usando APP_KEY_SUFFIX implicitamente nas chaves de session_state
            contexto_para_ia_local = None
            processed_file_id_key = f'processed_file_id_{area_chave}{APP_KEY_SUFFIX}'
            uploaded_info_key = f'uploaded_file_info_{area_chave}_for_prompt{APP_KEY_SUFFIX}'
            user_input_processed_key = f'user_input_processed_{area_chave}{APP_KEY_SUFFIX}'

            if uploaded_files_objs: # uploaded_files_objs √© uma lista de UploadedFile
                current_file_signature = "-".join(sorted([f"{f.name}-{f.size}-{f.file_id}" for f in uploaded_files_objs])) # Usar file_id
                if st.session_state.get(processed_file_id_key) != current_file_signature or not st.session_state.get(uploaded_info_key):
                    text_contents, image_info = [], []
                    for f_item in uploaded_files_objs:
                        try:
                            if f_item.type == "text/plain": text_contents.append(f"Arquivo '{f_item.name}':\n{f_item.read().decode('utf-8')[:3000]}...") # Limita o tamanho para contexto
                            elif f_item.type in ["image/png","image/jpeg"]: st.image(Image.open(f_item),caption=f"Contexto: {f_item.name}",width=100); image_info.append(f"Imagem '{f_item.name}'.")
                        except Exception as e_file_proc: st.error(f"Erro ao processar '{f_item.name}': {e_file_proc}")
                    full_ctx_str = ("\n\n--- TEXTO DOS ARQUIVOS ---\n" + "\n\n".join(text_contents) if text_contents else "") + \
                                   ("\n\n--- IMAGENS FORNECIDAS ---\n" + "\n".join(image_info) if image_info else "")
                    if full_ctx_str.strip(): st.session_state[uploaded_info_key] = full_ctx_str.strip(); contexto_para_ia_local = st.session_state[uploaded_info_key]; st.info("Arquivo(s) de contexto pronto(s).")
                    else: st.session_state[uploaded_info_key] = None
                    st.session_state[processed_file_id_key] = current_file_signature
                else: contexto_para_ia_local = st.session_state.get(uploaded_info_key)
            kwargs_chat = {}
            if contexto_para_ia_local and not st.session_state.get(user_input_processed_key, False): kwargs_chat['contexto_arquivos'] = contexto_para_ia_local
            exibir_chat_e_obter_input(area_chave, prompt_placeholder, funcao_conversa_agente, **kwargs_chat)
            if user_input_processed_key in st.session_state and st.session_state[user_input_processed_key]:
                if st.session_state.get(uploaded_info_key): st.session_state[uploaded_info_key] = None
                st.session_state[user_input_processed_key] = False

        # --- Instancia√ß√£o do Agente ---
        if 'agente_pme' not in st.session_state or not isinstance(st.session_state.agente_pme, AssistentePMEPro) or st.session_state.agente_pme.llm != llm_model_instance : # Adicionada verifica√ß√£o do llm
            st.session_state.agente_pme = AssistentePMEPro(llm_passed_model=llm_model_instance)
        agente = st.session_state.agente_pme
        
        # --- Interface da Sidebar (ap√≥s login) ---
        st.sidebar.write(f"Logado como: {display_email}")
        if st.sidebar.button("Logout", key=f"main_app_logout{APP_KEY_SUFFIX}"): # Usando APP_KEY_SUFFIX
            st.session_state.user_session_pyrebase = None
            # Limpeza de chaves de sess√£o
            st.session_state.pop('firebase_init_success_message_shown', None)
            st.session_state.pop('firebase_app_instance', None) 
            st.session_state.pop('llm_init_success_sidebar_shown_main_app', None)
            # Limpar chaves espec√≠ficas do app (usando APP_KEY_SUFFIX e prefixos comuns)
            keys_to_clear_on_logout = [k for k in st.session_state if APP_KEY_SUFFIX in k or k.startswith('memoria_') or k.startswith('chat_display_') or k.startswith('generated_') or k.startswith('post_') or k.startswith('campaign_')]
            keys_to_clear_on_logout.append('agente_pme')
            keys_to_clear_on_logout.append('area_selecionada') # Chave de navega√ß√£o principal
            for key_to_clear in keys_to_clear_on_logout: 
                st.session_state.pop(key_to_clear, None)
            st.rerun()

        # Logo da Sidebar (Corrigido para usar try-except)
        LOGO_PATH_SIDEBAR_APP = "images/logo-pme-ia.png" # Certifique-se que √© 'images'
        FALLBACK_LOGO_URL_SIDEBAR_APP = "https://i.imgur.com/7IIYxq1.png"
        try:
            st.sidebar.image(LOGO_PATH_SIDEBAR_APP, width=150)
        except Exception:
            st.sidebar.image(FALLBACK_LOGO_URL_SIDEBAR_APP, width=150, caption="Logo (Fallback)")

        st.sidebar.title("Assistente PME Pro")
        st.sidebar.markdown("IA para seu Neg√≥cio Decolar!")
        st.sidebar.markdown("---")

        # --- L√≥gica de Navega√ß√£o Principal (Sidebar) (do seu c√≥digo) ---
        opcoes_menu = {
            "P√°gina Inicial": "pagina_inicial", 
            "Marketing Digital com IA (Guia)": "marketing_guiado",
            "Elaborar Plano de Neg√≥cios com IA": "plano_negocios", 
            "C√°lculo de Pre√ßos Inteligente": "calculo_precos",
            "Gerador de Ideias para Neg√≥cios": "gerador_ideias"
        }
        radio_key_sidebar_main = f'sidebar_selection{APP_KEY_SUFFIX}_main' # Usando APP_KEY_SUFFIX
        
        if 'area_selecionada' not in st.session_state or st.session_state.area_selecionada not in opcoes_menu:
            st.session_state.area_selecionada = "P√°gina Inicial"
        
        # Gerenciamento do √≠ndice do radio button para persist√™ncia
        radio_index_key_nav = f'{radio_key_sidebar_main}_index'
        if radio_index_key_nav not in st.session_state:
            try:
                st.session_state[radio_index_key_nav] = list(opcoes_menu.keys()).index(st.session_state.area_selecionada)
            except ValueError: # Caso 'area_selecionada' seja inv√°lida
                st.session_state[radio_index_key_nav] = 0
                st.session_state.area_selecionada = list(opcoes_menu.keys())[0]
        
        def update_main_radio_index_on_change_app(): # Nome da fun√ß√£o de callback atualizado
             st.session_state[radio_index_key_nav] = list(opcoes_menu.keys()).index(st.session_state[radio_key_sidebar_main])

        area_selecionada_label = st.sidebar.radio(
            "Como posso te ajudar hoje?", 
            options=list(opcoes_menu.keys()), 
            key=radio_key_sidebar_main, 
            index=st.session_state[radio_index_key_nav], # Usando a chave de √≠ndice correta
            on_change=update_main_radio_index_on_change_app # Callback corrigido
        )

        if area_selecionada_label != st.session_state.area_selecionada:
            st.session_state.area_selecionada = area_selecionada_label
            # Limpar estados de marketing se sair da se√ß√£o
            if area_selecionada_label != "Marketing Digital com IA (Guia)":
                keys_to_clear_marketing_nav = [k for k in st.session_state if k.startswith(f"generated_") and APP_KEY_SUFFIX in k or k.startswith(f"post_{APP_KEY_SUFFIX}") or k.startswith(f"campaign_{APP_KEY_SUFFIX}")]
                for key_clear_nav_mkt in keys_to_clear_marketing_nav:
                    st.session_state.pop(key_clear_nav_mkt, None)
            st.rerun() 

        current_section_key = opcoes_menu.get(st.session_state.area_selecionada)
        
        # Inicializar chats quando a se√ß√£o √© selecionada pela primeira vez ou mudada
        if current_section_key not in ["pagina_inicial", "marketing_guiado"]:
            chat_init_flag_key_app = f'previous_area_selecionada_for_chat_init{APP_KEY_SUFFIX}' # Usando APP_KEY_SUFFIX
            chat_display_key_specific_app = f"chat_display_{current_section_key}{APP_KEY_SUFFIX}" # Usando APP_KEY_SUFFIX
            
            # Verifica se precisa reinicializar o chat
            needs_chat_reset = False
            if st.session_state.area_selecionada != st.session_state.get(chat_init_flag_key_app):
                needs_chat_reset = True
            elif chat_display_key_specific_app not in st.session_state:
                needs_chat_reset = True
            elif not st.session_state.get(chat_display_key_specific_app): # Se a lista de chat estiver vazia
                needs_chat_reset = True

            if needs_chat_reset:
                msg_inicial_nav, memoria_agente_nav = "", None
                if current_section_key == "plano_negocios": msg_inicial_nav, memoria_agente_nav = "Ol√°! Sou seu Assistente PME Pro. Vamos elaborar um rascunho do seu plano de neg√≥cios? Comece me contando sobre sua ideia.", agente.memoria_plano_negocios
                elif current_section_key == "calculo_precos": msg_inicial_nav, memoria_agente_nav = "Ol√°! Para calcular pre√ßos, descreva seu produto/servi√ßo. Pode enviar uma imagem.", agente.memoria_calculo_precos
                elif current_section_key == "gerador_ideias": msg_inicial_nav, memoria_agente_nav = "Ol√°! Buscando ideias? Descreva seu desafio ou envie arquivos de contexto.", agente.memoria_gerador_ideias
                
                if msg_inicial_nav and memoria_agente_nav is not None:
                    inicializar_ou_resetar_chat(current_section_key, msg_inicial_nav, memoria_agente_nav)
                st.session_state[chat_init_flag_key_app] = st.session_state.area_selecionada


        # --- SELE√á√ÉO E EXIBI√á√ÉO DA SE√á√ÉO ATUAL (do seu c√≥digo) ---
        if current_section_key == "pagina_inicial":
            st.markdown("<div style='text-align: center;'><h1>üöÄ Bem-vindo ao seu Assistente PME Pro!</h1></div>", unsafe_allow_html=True)
            st.markdown("<div style='text-align: center;'><p style='font-size: 1.1em;'>Sou seu parceiro de IA dedicado a impulsionar o sucesso de Pequenas e M√©dias Empresas.</p></div>", unsafe_allow_html=True)
            st.markdown("<div style='text-align: center;'><p style='font-size: 1.1em;'>Use o menu √† esquerda para navegar pelas ferramentas e come√ßar a transformar seu neg√≥cio.</p></div>", unsafe_allow_html=True)
            st.markdown("---")
            # LOGO DA P√ÅGINA INICIAL REMOVIDO CONFORME SEU PEDIDO
            st.markdown("---")
            
            num_botoes_funcionais = len(opcoes_menu) -1 
            if num_botoes_funcionais > 0 :
                num_cols_render = min(num_botoes_funcionais, 3) 
                cols_botoes_pg_inicial = st.columns(num_cols_render)
                btn_idx_pg_inicial = 0
                for nome_menu_btn_pg, chave_secao_btn_pg in opcoes_menu.items():
                    if chave_secao_btn_pg != "pagina_inicial":
                        col_para_botao_pg = cols_botoes_pg_inicial[btn_idx_pg_inicial % num_cols_render]
                        button_label_pg = nome_menu_btn_pg.split(" com IA")[0].split(" (Guia)")[0].replace("Elaborar ", "").replace(" Inteligente","").replace(" para Neg√≥cios","")
                        if col_para_botao_pg.button(button_label_pg, key=f"btn_goto_{chave_secao_btn_pg}{APP_KEY_SUFFIX}", use_container_width=True, help=f"Ir para {nome_menu_btn_pg}"): # Usando APP_KEY_SUFFIX
                            st.session_state.area_selecionada = nome_menu_btn_pg
                            try: # Atualiza o √≠ndice do radio button da sidebar
                                st.session_state[radio_index_key_nav] = list(opcoes_menu.keys()).index(nome_menu_btn_pg)
                            except ValueError: pass
                            st.rerun()
                        btn_idx_pg_inicial +=1
                st.balloons()

        elif current_section_key == "marketing_guiado": 
            agente.marketing_digital_guiado() # Certifique-se que as chaves internas usam APP_KEY_SUFFIX
        elif current_section_key == "plano_negocios": 
            st.header("üìù Elaborando seu Plano de Neg√≥cios com IA")
            st.caption("Converse com o assistente para desenvolver se√ß√µes do seu plano de neg√≥cios, obter insights e refinar suas estrat√©gias.")
            exibir_chat_e_obter_input(current_section_key, "Sua resposta ou pr√≥xima se√ß√£o do plano...", agente.conversar_plano_de_negocios)
            _sidebar_clear_button("Plano", agente.memoria_plano_negocios, current_section_key) # APP_KEY_SUFFIX usado internamente
        elif current_section_key == "calculo_precos": 
            st.header("üí≤ C√°lculo de Pre√ßos Inteligente com IA")
            st.caption("Descreva seu produto/servi√ßo, custos, mercado e objetivos. Envie uma imagem se ajudar.")
            uploaded_image_calc = st.file_uploader("Envie uma imagem do produto (opcional):", type=["png", "jpg", "jpeg"], key=f"preco_img{APP_KEY_SUFFIX}") # Usando APP_KEY_SUFFIX
            _handle_chat_with_image("calculo_precos", "Descreva o produto/servi√ßo, custos, etc.", agente.calcular_precos_interativo, uploaded_image_calc) # APP_KEY_SUFFIX usado internamente
            _sidebar_clear_button("Pre√ßos", agente.memoria_calculo_precos, current_section_key) # APP_KEY_SUFFIX usado internamente
        elif current_section_key == "gerador_ideias": 
            st.header("üí° Gerador de Ideias para seu Neg√≥cio com IA")
            st.caption("Descreva um desafio, uma √°rea que quer inovar, ou pe√ßa sugest√µes. Envie arquivos de texto ou imagem para dar mais contexto.")
            uploaded_files_ideias_ui = st.file_uploader("Envie arquivos de contexto (opcional - .txt, .png, .jpg):", type=["txt", "png", "jpg", "jpeg"], accept_multiple_files=True, key=f"ideias_file_uploader{APP_KEY_SUFFIX}") # Usando APP_KEY_SUFFIX
            _handle_chat_with_files("gerador_ideias", "Descreva seu desafio ou pe√ßa ideias:", agente.gerar_ideias_para_negocios, uploaded_files_ideias_ui) # APP_KEY_SUFFIX usado internamente
            _sidebar_clear_button("Ideias", agente.memoria_gerador_ideias, current_section_key) # APP_KEY_SUFFIX usado internamente
    
    else: # Se llm_model_instance n√£o foi inicializado
        st.error("üö® O Assistente PME Pro n√£o p√¥de ser iniciado.")
        st.info("Isso pode ter ocorrido devido a um problema com a chave da API do Google ou ao contatar os servi√ßos do Google Generative AI.")
        if llm_init_exception: # Mostra a exce√ß√£o espec√≠fica se dispon√≠vel
            st.exception(llm_init_exception)


# --- Se√ß√£o de Login/Registro (executada se user_is_authenticated for False) ---
else: 
    st.session_state.pop('auth_error_shown', None) 
    st.title("üîë Bem-vindo ao Assistente PME Pro") # T√≠tulo da aplica√ß√£o na tela de login

    # Forms de Login/Registro na Sidebar
    st.sidebar.subheader("Login / Registro")
    auth_action_choice_key = "app_auth_choice_pyrebase" # Chave √∫nica para o radio da autentica√ß√£o
    auth_action_choice = st.sidebar.radio("A√ß√£o:", ("Login", "Registrar Novo Usu√°rio"), key=auth_action_choice_key)

    if auth_action_choice == "Login":
        with st.sidebar.form("app_login_form_pyrebase"): # Chave √∫nica para o form de login
            login_email = st.text_input("Email")
            login_password = st.text_input("Senha", type="password")
            login_button_clicked = st.form_submit_button("Login")
            if login_button_clicked:
                if login_email and login_password and pb_auth_client:
                    try:
                        user_session = pb_auth_client.sign_in_with_email_and_password(login_email, login_password)
                        st.session_state.user_session_pyrebase = dict(user_session)
                        st.session_state.pop('firebase_init_success_message_shown', None) # Para n√£o mostrar novamente ap√≥s login
                        st.rerun()
                    except Exception as e_login:
                        error_message_login = "Erro no login. Verifique suas credenciais."
                        try: 
                            error_details_str = e_login.args[0] if len(e_login.args) > 0 else "{}"
                            error_data = json.loads(error_details_str.replace("'", "\""))
                            api_error_message = error_data.get('error', {}).get('message', '')
                            if "INVALID_LOGIN_CREDENTIALS" in api_error_message or "EMAIL_NOT_FOUND" in api_error_message or "INVALID_PASSWORD" in api_error_message or "USER_DISABLED" in api_error_message or "INVALID_EMAIL" in api_error_message:
                                error_message_login = "Email ou senha inv√°lidos, ou usu√°rio desabilitado."
                            elif api_error_message: error_message_login = f"Erro no login: {api_error_message}"
                        except: pass # Ignora erros de parsing da mensagem de erro do Firebase, usa a gen√©rica
                        st.sidebar.error(error_message_login)
                elif not pb_auth_client: st.sidebar.error("Cliente Firebase Auth n√£o inicializado.")
                else: st.sidebar.warning("Por favor, preencha email e senha.")
    
    elif auth_action_choice == "Registrar Novo Usu√°rio":
        with st.sidebar.form("app_register_form_pyrebase"): # Chave √∫nica para o form de registro
            reg_email = st.text_input("Email para registro")
            reg_password = st.text_input("Senha para registro (m√≠nimo 6 caracteres)", type="password")
            submit_register = st.form_submit_button("Registrar")
            if submit_register:
                if reg_email and reg_password and pb_auth_client:
                    try:
                        user = pb_auth_client.create_user_with_email_and_password(reg_email, reg_password)
                        st.sidebar.success(f"Usu√°rio {reg_email} registrado! Por favor, fa√ßa o login.")
                        try: # Tenta enviar email de verifica√ß√£o
                           pb_auth_client.send_email_verification(user['idToken'])
                           st.sidebar.info("Email de verifica√ß√£o enviado (cheque sua caixa de entrada e spam).")
                        except Exception as verify_email_error_local: # Renomeada vari√°vel de exce√ß√£o
                           st.sidebar.caption(f"Nota: N√£o foi poss√≠vel enviar email de verifica√ß√£o: {verify_email_error_local}")
                    except Exception as e_register:
                        error_message_register = "Erro no registro."
                        try:
                            error_details_str = e_register.args[0] if len(e_register.args) > 0 else "{}"
                            error_data = json.loads(error_details_str.replace("'", "\""))
                            api_error_message = error_data.get('error', {}).get('message', '')
                            if "EMAIL_EXISTS" in api_error_message:
                                error_message_register = "Este email j√° est√° registrado. Tente fazer login."
                            elif api_error_message:
                                error_message_register = f"Erro no registro: {api_error_message}"
                        except: # Ignora erros de parsing, usa mensagem gen√©rica + str(e)
                             error_message_register = f"Erro no registro: {str(e_register)}"
                        st.sidebar.error(error_message_register)
                elif not pb_auth_client: st.sidebar.error("Cliente Firebase Auth n√£o inicializado.")
                else: st.sidebar.warning("Por favor, preencha email e senha para registro.")
    
    # Conte√∫do da p√°gina de login (quando n√£o autenticado)
    if not error_message_firebase_init: 
        st.info("Fa√ßa login ou registre-se na barra lateral para usar o Assistente PME Pro.")
        # Logo da tela de login (Corrigido para usar try-except)
        LOGO_PATH_LOGIN_UNAUTH = "images/logo-pme-ia.png" 
        FALLBACK_LOGO_URL_LOGIN_UNAUTH = "https://i.imgur.com/7IIYxq1.png"
        try:
            st.image(LOGO_PATH_LOGIN_UNAUTH, width=200)
        except Exception:
            st.image(FALLBACK_LOGO_URL_LOGIN_UNAUTH, width=200, caption="Logo (Fallback)")

# Rodap√© da Sidebar (sempre vis√≠vel)
st.sidebar.markdown("---")
st.sidebar.info("Desenvolvido por Yaakov Israel com Gemini Pro")
